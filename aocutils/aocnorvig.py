# AUTOGENERATED! DO NOT EDIT! File to edit: 02_norvig.ipynb (unless otherwise specified).

__all__ = ['data', 'do', 'quantify', 'first', 'rest', 'multimap', 'prod', 'ints', 'test', 'atom', 'atoms', 'list_atoms',
           'dotproduct', 'mapt', 'cat', 'flatten', 'Char', 'zippify']

# Cell
from collections import Counter, defaultdict, namedtuple, deque
from itertools   import permutations, combinations, product, chain
from functools   import lru_cache
from typing      import Dict, Tuple, Set, List, Iterator, Optional, Union, Iterable
import numpy as np
import operator
import math
import ast
import sys
import re

# Cell
def data(filename='input', parser=str, sep='\n') -> list:
    "Split the day's input file into sections separated by `sep`, and apply `parser` to each."
    sections = open(f'{filename}.txt').read().rstrip().split(sep)
    return [parser(section) for section in sections]

def do(day, *answers) -> Dict[int, int]:
    "E.g., do(3) returns {1: day3_1(in3), 2: day3_2(in3)}. Verifies `answers` if given."
    g = globals()
    got = []
    for part in (1, 2):
        fname = f'day{day}_{part}'
        if fname in g:
            got.append(g[fname](g[f'in{day}']))
            if len(answers) >= part:
                assert got[-1] == answers[part - 1], (
                    f'{fname}(in{day}) got {got[-1]}; expected {answers[part - 1]}')
    return got

# Cell
def quantify(iterable, pred=bool) -> int:
    "Count the number of items in iterable for which pred is true."
    return sum(1 for item in iterable if pred(item))

# Cell
def first(iterable, default=None) -> object:
    "Return first item in iterable, or default."
    return next(iter(iterable), default)

# Cell
def rest(sequence) -> object: return sequence[1:]

# Cell
def multimap(items: Iterable[Tuple]) -> dict:
    "Given (key, val) pairs, return {key: [val, ....], ...}."
    result = defaultdict(list)
    for key, val in items:
        result[key].append(val)
    return result

# Cell
def prod(numbers) -> float: # Will be math.prod in Python 3.8, but I'm in 3.7
    "The product of an iterable of numbers."
    result = 1
    for n in numbers:
        result *= n
    return result
assert prod([1,2,3]) == 6

# Cell
def ints(text: str) -> Tuple[int]:
    "Return a tuple of all the integers in text."
    return tuple(map(int, re.findall('-?[0-9]+', text)))

# Cell
def test():
    print('haaa')

# Cell
def atom(text: str) -> Union[float, int, str]:
    "Parse text into a single float or int or str."

    try:
        val = float(text)
        return round(val) if round(val) == val else val
    except ValueError:
        return text
atom('11') == 11


# Cell
def atoms(text: str, ignore=r'', sep=None) -> Tuple[Union[int, str]]:
    "Parse text into atoms (numbers or strs), possibly ignoring a regex."
    if ignore:
        text = re.sub(ignore, '', text)
    return tuple(map(atom, text.split(sep)))
atoms('abc 111 def')

# Cell
def list_atoms(inp: List):
    return tuple(map(atom, inp))


# Cell
def dotproduct(A, B) -> float: return sum(a * b for a, b in zip(A, B))
dotproduct([1,2],[7,8]) == 23

# Cell
def mapt(fn, *args):
    "map(fn, *args) and return the result as a tuple."
    return tuple(map(fn, *args))
mapt(lambda x: x+'z', list('abcde'))

# Cell
cat = ''.join
flatten = chain.from_iterable
Char = str # Type used to indicate a single character

# Cell
def zippify(iterable, num_args, cat=False):
    iterable_collection = [iterable[i:] for i in range(num_args)]
    res = [args for args in zip(*iterable_collection)]
    return [''.join(r) for r in res] if cat else res
zippify('abcdef',3, cat=True)