# AUTOGENERATED! DO NOT EDIT! File to edit: 07_shunting_yard.ipynb (unless otherwise specified).

__all__ = ['md5', 'binarysearch', 'deduce_matches', 'find_pattern_in_iter', 'find_repeat', 'find_cycle', 'CFG',
           'ShuntingYard']

# Internal Cell
from collections.abc import Iterable
from collections import namedtuple, deque
import contextlib
from functools import reduce
import hashlib
import heapq
import logging
from math import sqrt, gcd
from pathlib import Path
import time
import pickle
import pandas as pd
import numpy as np

DATA_DIR = Path('data')

# Cell
def md5(input):
    return hashlib.md5(input.encode('utf-8')).hexdigest()


# Cell

def binarysearch(minim,maxim,function, flips_to_true=True):
    """
     function needs to return a boolean whether the solution is ok
     this implementation is for function that starts with false for minim and flip to true
     for TTTTFFFF, pass set flips_to_true flag to false. This flag is important to set correct!
    """
    new = minim
    while True:
        new = (minim+maxim)//2
        print(f'to_test: {new}, min {minim}, max {maxim} ', end=' ')
        res = function(new)
        print('function returns', res)
        if not flips_to_true: res = not res
        if res:
            if new == maxim: # solution found
                if flips_to_true:
                    print('solution found',new)
                    return new
                else:
                    print('solution found',new-1)
                    return new-1
            maxim = new
        else: minim = new+1


# Cell
def deduce_matches(input_dict, option_type=str):
    """
    Takes a dict with multiple keys that have one or more options
    The trick is to start with what you know: keys with one option and remove that option for the other keys
    Continuing that process leads to every key ending up with one option (hopefully)

    Assumes: the options are strings and sort in some kind of container
    """
    found = 0
    while found < len(input_dict):
        for k, v in input_dict.items():
            if not isinstance(v, option_type) and len(v) == 1: # found one
                to_rem = v.pop()
                input_dict[k] = to_rem
                found += 1
                for _ , v2 in input_dict.items(): # remove the item from other lists
                    if not isinstance(v2, option_type) and to_rem in v2:
                        v2.remove(to_rem)
    return input_dict

# Cell
def find_pattern_in_iter(start_pattern, function, goal = None, n_iter=1000000000):
    """
        Returns when a SPECIFIED pattern has been found from a function
        If goal = None, then first time the start pattern shows up again is returned
        Returns steps, pattern
    """
    if not goal: goal = start_pattern
    current = start_pattern
    for i in range(1,n_iter):
        current = function(current)
        # print(current)
        if current == goal:
            print(f'At step {i}, goal: {current} was found')
            return i, current

# Cell
def find_repeat(start_pattern, function, n_iter=None):
    """
        Returns when a NONSPECFIED repeating pattern has been found
        Returns steps, pattern
    """
    if not n_iter: n_iter = round(10e20)
    seen = {start_pattern}
    current = start_pattern
    for i in range(1,n_iter):
        current = function(current)
        # print(current)
        if current in seen:
            print(f'Repeat was found at step {i}. Pattern: {current}')
            return i,current
        seen.add(current)

# Cell
def find_cycle(start_pattern, function):
    """
        Find cycle length of some repeating pattern, by first inspecting which item repeats when
        And subtracting the time the item was first seen
    """
    step_second, pattern = find_repeat(start_pattern, function)
    step_first, pattern = find_pattern_in_iter(start_pattern, function, goal = pattern)
    return step_second - step_first

# Internal Cell
from collections import defaultdict
from itertools import product

# Cell


class CFG():
    """"Takes a grammer as dict with tuple of options as values. Terminal values should not be in a tuple but as a string
    Usage:
        cfg = CFG(grammar_dict)
            reverse as optional parameter when k,v are reversed
            converts the grammar to Chomsky Normal form by taking care of options, unit productions and triplets
        cfg.solve(messages_list) returns dict of substrings with possible rules to make them
    """
    def __init__(self, grammar = None, reverse = True):
        self.outcomes = defaultdict(set)
        if grammar:
            # convert grammar to CNF and add terminals to outcomes
            self.grammar = self.grammar_to_cnf(grammar, reverse)
            self.outcomes.update({k:v for k,v in self.grammar.items() if isinstance(k, str)})


    def grammar_to_cnf(self, grammar, reverse):
        grammar = self.to_cnf_remove_options(grammar, reverse)
        grammar = self.to_cnf_remove_triplets(grammar)
        return self.to_cnf_remove_unit_productions(grammar)

    def to_cnf_remove_options(self, grammar, reverse):
        # if reverse change from X : AB to AB : {X}
        # if there are options, these are given a separate entry, e.g.
        # X : (AB, CD) --> X: AB and X: CD
        new_grammar = defaultdict(set)
        if reverse:
            for k,v in grammar.items():
                for option in v:
                    new_grammar[option].add(k)
        else:
            for k,v in grammar.items():
                for option in k:
                    new_grammar[option].add(v)
        return new_grammar

    def to_cnf_remove_triplets(self, grammar):
        # reduces triplets or larger to pairs
        # changes X : ABC to
        # X: AY, Y = BC
        new_grammar = defaultdict(set)
        for k,v in grammar.items():
            if len(k) > 2:
                for i, t in enumerate(k[0:-2]):
                    newvar = str(v) + '_' + str(i)
                    oldvar = str(v) + '_' + str(i-1)
                    if i == 0:
                        new_grammar[t,newvar] = v
                    else:
                        new_grammar[t,newvar] = {oldvar}
                new_grammar[k[-2:]].add(newvar)
            else:
                new_grammar[k] |= v
        return new_grammar


    def to_cnf_remove_unit_productions(self,grammar):
        # step to get to Chomsky Normal Form
        # if X : A, duplicate all A : Y with X : Y
        singulars = {k[0]:next(iter(v)) for k,v in grammar.items() if len(k)!=2 and not isinstance(k,str)}
        for k,v in singulars.items():
            for j in grammar.values():
                if k in j:
                    j.add(v)
        return grammar

    def pieces(self, test,l):
        # gets all possibilities of len l out of a string
        assert isinstance(test, str)
        return {test[i:i+l] for i in range(len(test)-l+1) if test[i:i+l] not in self.outcomes}

    def splitter(self,option):
        # splits string into all options of two substrings
        assert isinstance(option, str)
        return {(option[:i], option[i:]) for i in range(1,len(option))}

    def check_possible_option(self, option):
        first = self.outcomes[option[0]]
        second = self.outcomes[option[1]]
        res = set()
        for potential in product(first,second):
            if potential in self.grammar: res |= self.grammar[potential]
        return res

    def solve(self, messages):
        # takes a list of messages and returns all possibilities for the substrings of m
        for num, m in enumerate(messages):
            if num % 100 == 0: print(num*10, 'messages done')
            for i in range(2,len(m)+1):
                for j in self.pieces(m, i):
                    for k in self.splitter(j):
                        res = self.check_possible_option(k)
                        if res:
                            self.outcomes[j] |= res
        print('finished all messages, returning dict')
        return self.outcomes




# Internal Cell
import math
from collections import deque
from collections import defaultdict
import operator

left_associative = {'-', '/', '+', '*'}


# Cell
# https://en.wikipedia.org/wiki/Associative_property
# https://en.wikipedia.org/wiki/Shunting-yard_algorithm





class ShuntingYard:
    """
    Init with a precedence dictionary. Then call SY.calc(line), with a string as input

    Example precedence dictionary. Higher numbers have a higher precedence:
    prec = defaultdict(lambda: int(9))
    prec.update({'*':4,
            '+':4,
            '/':4,
            ':':4,
            '-':4,
            '^':4,
            '**':4})

    self.ops is a dictionary with the functions that are called with certain symbols, e.g.
    Example self.ops:
    self.ops = {
            '+' : operator.add,
            '-' : operator.sub,
            '*' : operator.mul,
            '/' : operator.truediv,
            ':' : operator.truediv,
            '%' : operator.mod,
            '^' : operator.xor,
            '**' : pow,
        }


    """
    def __init__(self, prec=None, ops=None):
        self.prec = {
            '**':7,
            '/':6,
            '*':6,
            ':':6,
            '+':5,
            '-':5,
            '<<':4,
            '>>': 4,
            '&': 3,
            '^':2,
            '|': 1} if not prec else prec

        self.ops = {
            '+' : operator.add,
            '-' : operator.sub,
            '*' : operator.mul,
            '/' : operator.truediv,
            ':' : operator.truediv,
            '%' : operator.mod,
            '^' : operator.xor,
            '**' : pow,
        } if not ops else ops

    def is_callable_string(self, s):
        try:
            res = eval(f'callable({s})')
        except Exception:
            return False
        return True

    def get_postfix(self, list_of_symbols):
        op_stack = deque()
        output_stack = deque()

        for symbol in list_of_symbols:
            # print(output_stack, op_stack)
            if isinstance(symbol, int):
                output_stack.append(symbol)
            elif self.is_callable_string(symbol):
                op_stack.append(symbol)
            elif symbol in self.prec:
                while (op_stack and op_stack[-1] != '(' and (
                    self.prec[op_stack[-1]] > self.prec[symbol] or
                    (self.prec[op_stack[-1]] == self.prec[symbol] and symbol in '-/*+'))):
                    output_stack.append(op_stack.pop())
                op_stack.append(symbol)

            elif symbol == '(': op_stack.append(symbol)
            elif symbol == ')':
                while op_stack[-1] != '(':
                    output_stack.append(op_stack.pop())
                if op_stack and op_stack[-1]=='(':
                    op_stack.pop() # remove the (
                if op_stack and callable(op_stack[-1]):
                    output_stack.append(op_stack.pop())
        while op_stack:
            output_stack.append(op_stack.pop())

        return output_stack

    def eval_postfix(self, output_stack):
        res = []
        for symbol in output_stack:
            if isinstance(symbol, int): res.append(symbol)
            else:
                second, first = res.pop(), res.pop()
                if symbol in self.ops:
                    temp = self.ops[symbol](first, second)
                else:
                    temp = eval(f'{symbol}({first},{second})')
                res.append(temp)
        return res[0]

    def calc(self, line):
        line = line.replace("(","( ").replace(")"," )")
        line = [int(arg) if arg.isnumeric() else arg for arg in line.split()]
        return self.eval_postfix(self.get_postfix(line))